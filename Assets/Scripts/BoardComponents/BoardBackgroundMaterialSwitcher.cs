// Generated by GPT-5.2 (Cursor), for jjmil, on 2026-02-15.
using System;
using UnityEngine;
using UnityEngine.SceneManagement;

[DisallowMultipleComponent]
public sealed class BoardBackgroundMaterialSwitcher : MonoBehaviour
{
    [Header("Target")]
    [Tooltip("Renderer whose material will be swapped (ex: the board background mesh).")]
    [SerializeField] private Renderer targetRenderer;

    [Tooltip("Which material slot to replace on the renderer.")]
    [SerializeField] private int materialSlotIndex = 0;

    [Tooltip("If true, swaps sharedMaterials (recommended). If false, swaps instanced materials.")]
    [SerializeField] private bool useSharedMaterials = true;

    [Header("Materials")]
    [SerializeField] private Material normalMaterial;
    [SerializeField] private Material angelMaterial;
    [SerializeField] private Material devilMaterial;

    [Header("Runtime")]
    [Tooltip("If true, also checks each frame so changes apply immediately even mid-round.")]
    [SerializeField] private bool pollContinuouslyInPlayMode = true;

    private GameRulesManager rules;
    private RoundType lastAppliedType = (RoundType)(-1);

    private void Awake()
    {
        if (targetRenderer == null)
        {
            targetRenderer = GetComponent<Renderer>();
        }
    }

    private void OnEnable()
    {
        ResolveRules();
        Hook();

        SceneManager.sceneLoaded += OnSceneLoaded;

        RefreshNow();
    }

    private void OnDisable()
    {
        SceneManager.sceneLoaded -= OnSceneLoaded;

        Unhook();
    }

    private void Update()
    {
        if (!Application.isPlaying) return;
        if (!pollContinuouslyInPlayMode) return;

        RefreshNow();
    }

    private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
    {
        ResolveRules();
        Hook();

        RefreshNow();
    }

    private void ResolveRules()
    {
        if (rules != null) return;

#if UNITY_2022_2_OR_NEWER
        rules = FindFirstObjectByType<GameRulesManager>();
#else
        rules = FindObjectOfType<GameRulesManager>();
#endif
    }

    private void Hook()
    {
        if (rules == null) return;

        rules.RoundStarted -= OnRoundStarted;
        rules.RoundStarted += OnRoundStarted;

        rules.LevelChanged -= OnLevelChanged;
        rules.LevelChanged += OnLevelChanged;
    }

    private void Unhook()
    {
        if (rules == null) return;

        rules.RoundStarted -= OnRoundStarted;
        rules.LevelChanged -= OnLevelChanged;
    }

    private void OnRoundStarted()
    {
        RefreshNow(force: true);
    }

    private void OnLevelChanged()
    {
        RefreshNow(force: true);
    }

    [ContextMenu("Refresh Background Material Now")]
    public void RefreshNow()
    {
        RefreshNow(force: false);
    }

    private void RefreshNow(bool force)
    {
        if (targetRenderer == null) return;
        if (rules == null) ResolveRules();

        RoundType currentType = RoundType.Normal;
        if (rules != null && rules.CurrentRoundData != null)
        {
            currentType = rules.CurrentRoundData.type;
        }

        if (!force && currentType == lastAppliedType) return;

        Material chosen = ResolveMaterial(currentType);
        if (chosen == null) return;

        if (TrySwapMaterialSlot(targetRenderer, materialSlotIndex, chosen, useSharedMaterials))
        {
            lastAppliedType = currentType;
        }
    }

    private Material ResolveMaterial(RoundType type)
    {
        switch (type)
        {
            case RoundType.Angel:
                return angelMaterial != null ? angelMaterial : normalMaterial;
            case RoundType.Devil:
                return devilMaterial != null ? devilMaterial : normalMaterial;
            case RoundType.Normal:
            default:
                return normalMaterial;
        }
    }

    private static bool TrySwapMaterialSlot(
        Renderer r,
        int slotIndex,
        Material material,
        bool shared)
    {
        if (r == null) return false;
        if (material == null) return false;
        if (slotIndex < 0) return false;

        Material[] mats = shared ? r.sharedMaterials : r.materials;
        if (mats == null || mats.Length == 0) return false;
        if (slotIndex >= mats.Length) return false;

        if (mats[slotIndex] == material) return true;

        mats[slotIndex] = material;
        if (shared)
        {
            r.sharedMaterials = mats;
        }
        else
        {
            r.materials = mats;
        }

        return true;
    }
}

