using System;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

// Generated by Cursor AI (GPT-5.2) for jjmil on 2026-02-16.

/// <summary>
/// Controls the Shop overlay UI.
/// - Open/Close the shop canvas root
/// - Handles buying a new ball prefab.
///   If the player's "hand" (loadout) is full, they must replace an existing slot.
/// </summary>
public sealed class ShopUIController : MonoBehaviour
{
    public enum BallRarity
    {
        Common,
        Uncommon,
        Rare,
        Epic,
        Legendary
    }

    [Serializable]
    public class BallShopItem
    {
        public string displayName = "Ball";
        public GameObject ballPrefab;
        public int cost = 10;
        [TextArea] public string description;
        public BallRarity rarity = BallRarity.Common;
        [Tooltip("Optional: if set, use this instead of the prefab sprite icon.")]
        public Sprite iconOverride;
    }

    [Header("Refs")]
    [SerializeField] private GameRulesManager rulesManager;
    [SerializeField] private RunFlowController runFlowController;
    [SerializeField] private ShopTransitionController shopTransitionController;
    [Tooltip("Optional: root object for the shop canvas. If omitted, this component's GameObject will be toggled.")]
    [SerializeField] private GameObject shopCanvasRoot;
    [Tooltip("Optional: tab controller used to switch between Balls and Board Components screens.")]
    [SerializeField] private ShopTabsController tabsController;

    [Header("UI (optional)")]
    [Tooltip("Shown when a replacement slot must be chosen.")]
    [SerializeField] private GameObject replacePanelRoot;
    [Tooltip("Parent transform that will receive one instantiated entry per ball in hand.")]
    [SerializeField] private Transform replaceSlotsContainer;
    [Tooltip("Prefab with BallReplaceSlotEntryUI on it (Button + TMP + optional Image).")]
    [SerializeField] private BallReplaceSlotEntryUI replaceSlotEntryPrefab;
    [Tooltip("Optional: text inside the replace confirmation panel.")]
    [SerializeField] private TMP_Text replaceConfirmText;
    [Tooltip("Optional: image in the replace confirmation panel that shows the current ball in the slot.")]
    [SerializeField] private Image replaceCurrentBallIconImage;
    [Tooltip("Optional: image in the replace confirmation panel that shows the incoming/offer ball.")]
    [SerializeField] private Image replaceIncomingBallIconImage;

    [Header("Shop offers (dynamic)")]
    [Tooltip("Parent transform that will receive 3 instantiated offer entries each shop visit.")]
    [SerializeField] private Transform offersContainer;
    [Tooltip("Prefab with ShopBallOfferEntryUI on it.")]
    [SerializeField] private ShopBallOfferEntryUI offerEntryPrefab;
    [SerializeField] private int offersPerShop = 3;
    [SerializeField] private TMP_Text coinsText;
    [SerializeField] private TMP_Text promptText;

    [Header("Selected ball panel (optional)")]
    [SerializeField] private GameObject selectedEmptyStateRoot;
    [SerializeField] private GameObject selectedDetailsRoot;
    [SerializeField] private Image selectedIconImage;
    [SerializeField] private TMP_Text selectedNameText;
    [SerializeField] private TMP_Text selectedPriceText;
    [SerializeField] private TMP_Text selectedDescriptionText;
    [SerializeField] private TMP_Text selectedRarityText;
    [SerializeField] private Button selectedBuyButton;

    [Header("Catalog (all possible balls)")]
    [Tooltip("Preferred: centralized ball definitions (icon/name/rarity/description/price/prefab).")]
    [SerializeField] private List<BallDefinition> allBallDefinitions = new List<BallDefinition>();

    [Header("Catalog (legacy)")]
    [Tooltip("Legacy fallback. Convert these to BallDefinition assets for a scalable setup.")]
    [SerializeField] private List<BallShopItem> allBallItems = new List<BallShopItem>();

    private BallDefinition _pendingItem;
    private int _pendingReplaceSlotIndex = -1;
    private readonly List<BallDefinition> _currentOffers = new List<BallDefinition>(capacity: 3);
    private readonly List<ShopBallOfferEntryUI> _offerEntries = new List<ShopBallOfferEntryUI>(capacity: 3);
    private int _selectedOfferIndex = -1;
    private bool _closeRequested;

    private readonly List<BallDefinition> _legacyRuntimeDefinitions = new List<BallDefinition>();
    private bool _legacyRuntimeDefinitionsBuilt;
    private int _selectedHandSlotIndex = -1;

    private void Awake()
    {
        if (rulesManager == null)
        {
#if UNITY_2022_2_OR_NEWER
            rulesManager = FindFirstObjectByType<GameRulesManager>();
#else
            rulesManager = FindObjectOfType<GameRulesManager>();
#endif
        }

        if (runFlowController == null)
        {
#if UNITY_2022_2_OR_NEWER
            runFlowController = FindFirstObjectByType<RunFlowController>();
#else
            runFlowController = FindObjectOfType<RunFlowController>();
#endif
        }

        if (shopTransitionController == null)
        {
#if UNITY_2022_2_OR_NEWER
            shopTransitionController = FindFirstObjectByType<ShopTransitionController>();
#else
            shopTransitionController = FindObjectOfType<ShopTransitionController>();
#endif
        }

        if (shopCanvasRoot == null)
        {
            shopCanvasRoot = gameObject;
        }

        if (tabsController == null && shopCanvasRoot != null)
        {
            tabsController = shopCanvasRoot.GetComponentInChildren<ShopTabsController>(includeInactive: true);
        }

        ResolveReplacePanelIconImagesIfNeeded();
    }

    public void TrySwapHandSlots(int a, int b)
    {
        if (rulesManager == null)
        {
            return;
        }

        if (!rulesManager.SwapBallLoadoutSlots(a, b))
        {
            return;
        }

        // Swapping while a confirmation is open can become confusing, so close it.
        _pendingItem = null;
        _pendingReplaceSlotIndex = -1;
        SetReplacePanelOpen(false);
        ClearReplaceConfirmationVisuals();

        // Keep selected hand slot aligned if it was involved in the swap.
        if (_selectedHandSlotIndex == a)
        {
            _selectedHandSlotIndex = b;
        }
        else if (_selectedHandSlotIndex == b)
        {
            _selectedHandSlotIndex = a;
        }

        RebuildReplaceSlots();
        RefreshSelectedPanel();
        RefreshUI();
    }

    public void TryOfferDropOntoSlot(int offerIndex, int slotIndex)
    {
        if (rulesManager == null)
        {
            return;
        }

        if (offerIndex < 0 || offerIndex >= _currentOffers.Count)
        {
            return;
        }

        BallDefinition offer = _currentOffers[offerIndex];
        if (offer == null || !offer.IsValid())
        {
            return;
        }

        if (rulesManager.Coins < offer.Price)
        {
            SetPrompt($"Not enough coins for {offer.GetSafeDisplayName()}.");
            RefreshUI();
            return;
        }

        List<BallDefinition> loadout = rulesManager.GetBallLoadoutSnapshot();
        int count = loadout.Count;
        int cap = Mathf.Max(1, rulesManager.MaxBalls);

        bool isReplaceSlot = slotIndex >= 0 && slotIndex < count;
        bool isAddSlot = slotIndex == count && count < cap;
        if (!isReplaceSlot && !isAddSlot)
        {
            return;
        }

        _pendingItem = offer;
        _pendingReplaceSlotIndex = slotIndex;

        // Drag-drop should not permanently select the offer card.
        _selectedOfferIndex = -1;
        _selectedHandSlotIndex = isReplaceSlot ? slotIndex : -1;
        RefreshOfferEntrySelectionVisuals();
        RefreshSelectedPanel();

        RefreshReplaceConfirmationText();
        SetReplacePanelOpen(true);
        FMODUnity.RuntimeManager.PlayOneShot("event:/button_click");
        RefreshUI();
    }

    private void OnEnable()
    {
        _closeRequested = false;

        DisableBuyButtonIfPresent();
        ResolveReplacePanelIconImagesIfNeeded();

        // Canvas enabled by GameRulesManager; treat that as "open".
        HookTabs();
        if (tabsController != null)
        {
            // Default to balls screen every time the shop is opened.
            tabsController.SetTab(ShopTabsController.Tab.Balls, notify: false);
        }

        SetReplacePanelOpen(false);
        _pendingItem = null;
        _pendingReplaceSlotIndex = -1;
        ClearReplaceConfirmationVisuals();
        RebuildReplaceSlots();
        RebuildOffers();
        RefreshUI();
    }

    private void OnDisable()
    {
        UnhookTabs();
    }

    public void Open()
    {
        if (shopCanvasRoot != null)
        {
            shopCanvasRoot.SetActive(true);
        }

        DisableBuyButtonIfPresent();

        if (tabsController != null)
        {
            // If another system opened us without OnEnable (rare), ensure we start on Balls.
            tabsController.SetTab(ShopTabsController.Tab.Balls, notify: false);
        }

        RebuildReplaceSlots();
        RebuildOffers();
        ClearReplaceConfirmationVisuals();
        RefreshUI();
    }

    public void SelectOfferByIndex(int offerIndex)
    {
        if (offerIndex < 0 || offerIndex >= _currentOffers.Count)
        {
            return;
        }

        if (_currentOffers[offerIndex] == null)
        {
            return;
        }

        _selectedOfferIndex = offerIndex;
        _pendingItem = null;
        _pendingReplaceSlotIndex = -1;
        _selectedHandSlotIndex = -1;
        SetReplacePanelOpen(false);

        if (replaceConfirmText != null)
        {
            replaceConfirmText.text = string.Empty;
        }

        SetPrompt("Select a ball slot to replace (or empty slot to add).");
        RefreshSelectedPanel();
        RefreshOfferEntrySelectionVisuals();
    }

    public void BuySelectedOffer()
    {
        // Legacy entry point; new flow purchases by clicking a slot.
        SetPrompt("Select an offer, then click a slot to replace.");
        RefreshUI();
    }

    /// <summary>
    /// Close the shop and continue to the next round.
    /// Hook this to your "Close" / "Continue" button.
    /// </summary>
    public void CloseAndContinue()
    {
        if (_closeRequested)
            return;
        _closeRequested = true;

        SetReplacePanelOpen(false);
        _pendingItem = null;
        _pendingReplaceSlotIndex = -1;

        // Let RunFlowController handle the flow: show round preview over shop, then close shop.
        if (runFlowController != null)
        {
            runFlowController.ContinueAfterShop();
            return;
        }

        // Fallback: use transition controller directly.
        if (shopTransitionController != null)
        {
            shopTransitionController.CloseShopThen(() =>
            {
                if (rulesManager != null)
                {
                    rulesManager.OnShopClosed();
                    return;
                }

                if (shopCanvasRoot != null)
                {
                    shopCanvasRoot.SetActive(false);
                }
            });
            return;
        }

        // Fallback: old behavior.
        if (rulesManager != null)
        {
            rulesManager.OnShopClosed();
            return;
        }

        // Fallback: just hide the canvas.
        if (shopCanvasRoot != null)
        {
            shopCanvasRoot.SetActive(false);
        }
    }

    /// <summary>
    /// Begins the "buy ball" flow for an offer item at index (0..offersPerShop-1).
    /// If the hand/loadout is full, shows the replacement panel and waits for ChooseReplaceSlot().
    /// Hook this to each dynamic offer entry button.
    /// </summary>
    public void BuyOfferByIndex(int offerIndex)
    {
        if (rulesManager == null)
        {
            return;
        }

        if (offerIndex < 0 || offerIndex >= _currentOffers.Count)
        {
            return;
        }

        BallDefinition item = _currentOffers[offerIndex];
        if (item == null || !item.IsValid())
        {
            return;
        }

        // Check money first (do NOT spend until we know whether we're replacing or adding).
        if (rulesManager.Coins < item.Price)
        {
            SetPrompt($"Not enough coins for {item.GetSafeDisplayName()}.");
            RefreshUI();
            return;
        }

        int currentCount = rulesManager.BallLoadoutCount;
        int cap = Mathf.Max(1, rulesManager.MaxBalls);

        // If we have an open slot, buy immediately by adding to inventory.
        if (currentCount < cap)
        {
            if (!rulesManager.TrySpendCoins(item.Price))
            {
                SetPrompt($"Not enough coins for {item.GetSafeDisplayName()}.");
                RefreshUI();
                return;
            }

            bool added = rulesManager.AddBallToLoadout(item);
            if (!added)
            {
                // Shouldn't happen if currentCount < cap, but keep safe.
                SetPrompt($"Cannot add {item.GetSafeDisplayName()} (hand is full).");
                RefreshUI();
                return;
            }

            SetPrompt($"Purchased {item.GetSafeDisplayName()}.");
            SetReplacePanelOpen(false);
            _pendingItem = null;
            RebuildReplaceSlots();
            RebuildOffers();
            RefreshUI();
            return;
        }

        // Otherwise, must replace an existing slot.
        _pendingItem = item;
        _pendingReplaceSlotIndex = -1;
        RebuildReplaceSlots();
        SetReplacePanelOpen(false);
        SetPrompt($"Select a ball to replace with {item.GetSafeDisplayName()} (${item.Price}).");
        FMODUnity.RuntimeManager.PlayOneShot("event:/button_click");
        RefreshUI();
    }

    /// <summary>
    /// Selects which ball slot to apply the currently selected offer to.
    /// New flow:
    /// - Player clicks an offer to select it
    /// - Player clicks a slot (existing ball or the empty slot) to open confirmation
    /// </summary>
    public void ChooseReplaceSlot(int slotIndex)
    {
        if (rulesManager == null)
        {
            return;
        }

        List<BallDefinition> loadout = rulesManager.GetBallLoadoutSnapshot();
        int count = loadout.Count;
        int cap = Mathf.Max(1, rulesManager.MaxBalls);

        bool isReplaceSlot = slotIndex >= 0 && slotIndex < count;
        bool isAddSlot = slotIndex == count && count < cap;
        if (!isReplaceSlot && !isAddSlot)
        {
            return;
        }

        // If no offer is selected, treat this as "inspect my hand" and populate the selected panel.
        if (_selectedOfferIndex < 0 || _selectedOfferIndex >= _currentOffers.Count)
        {
            _pendingItem = null;
            _pendingReplaceSlotIndex = -1;
            SetReplacePanelOpen(false);
            if (replaceConfirmText != null)
            {
                replaceConfirmText.text = string.Empty;
            }

            _selectedOfferIndex = -1;
            _selectedHandSlotIndex = isReplaceSlot ? slotIndex : -1;
            RefreshOfferEntrySelectionVisuals();
            RefreshSelectedPanel();
            RefreshUI();
            return;
        }

        BallDefinition selectedOffer = _currentOffers[_selectedOfferIndex];
        if (selectedOffer == null || !selectedOffer.IsValid())
        {
            return;
        }

        if (rulesManager.Coins < selectedOffer.Price)
        {
            SetPrompt($"Not enough coins for {selectedOffer.GetSafeDisplayName()}.");
            RefreshUI();
            return;
        }

        _pendingItem = selectedOffer;
        _pendingReplaceSlotIndex = slotIndex;

        // Selecting a hand ball overrides the selected panel and deselects the offer.
        _selectedOfferIndex = -1;
        _selectedHandSlotIndex = isReplaceSlot ? slotIndex : -1;
        RefreshOfferEntrySelectionVisuals();
        RefreshSelectedPanel();

        RefreshReplaceConfirmationText();
        SetReplacePanelOpen(true);
        FMODUnity.RuntimeManager.PlayOneShot("event:/button_click");
        RefreshUI();
    }

    public void CancelPendingPurchase()
    {
        _pendingItem = null;
        _pendingReplaceSlotIndex = -1;
        FMODUnity.RuntimeManager.PlayOneShot("event:/button_click");
        SetReplacePanelOpen(false);
        SetPrompt(string.Empty);
        ClearReplaceConfirmationVisuals();
        RebuildReplaceSlots();
        RebuildOffers();
        RefreshUI();
    }

    /// <summary>
    /// Shows the round info/preview panel as an overlay.
    /// Hook this to a "View Rounds" button in the shop.
    /// </summary>
    public void ShowRoundInfo()
    {
        if (runFlowController != null)
        {
            runFlowController.ShowRoundPreviewOverlay();
        }
    }

    public void RefreshUI()
    {
        if (coinsText != null && rulesManager != null)
        {
            coinsText.text = $"${rulesManager.Coins}";
        }
    }

    private void HookTabs()
    {
        if (tabsController == null)
            return;

        tabsController.TabChanged -= OnTabChanged;
        tabsController.TabChanged += OnTabChanged;
    }

    private void UnhookTabs()
    {
        if (tabsController == null)
            return;

        tabsController.TabChanged -= OnTabChanged;
    }

    private void OnTabChanged(ShopTabsController.Tab tab)
    {
        // If the player is in the middle of a "choose slot to replace" flow, leaving the Balls tab
        // should safely abort it (otherwise they'd come back to a stale pending purchase).
        if (tab != ShopTabsController.Tab.Balls)
        {
            ClearPendingReplaceFlow();
        }
        else
        {
            // Coming back to Balls: ensure coin display is current.
            RefreshUI();
        }
    }

    private void ClearPendingReplaceFlow()
    {
        _pendingItem = null;
        _pendingReplaceSlotIndex = -1;
        SetReplacePanelOpen(false);
        SetPrompt(string.Empty);
        ClearReplaceConfirmationVisuals();
        RefreshUI();
    }

    public void ConfirmPendingReplacePurchase()
    {
        if (_pendingItem == null || rulesManager == null)
        {
            return;
        }

        int currentCount = rulesManager.BallLoadoutCount;
        int cap = Mathf.Max(1, rulesManager.MaxBalls);

        bool isReplaceSlot = _pendingReplaceSlotIndex >= 0 && _pendingReplaceSlotIndex < currentCount;
        bool isAddSlot = _pendingReplaceSlotIndex == currentCount && currentCount < cap;

        if (!isReplaceSlot && !isAddSlot)
        {
            return;
        }

        // Spend only at confirm-time.
        if (!rulesManager.TrySpendCoins(_pendingItem.Price))
        {
            SetPrompt($"Not enough coins for {_pendingItem.GetSafeDisplayName()}.");
            RefreshUI();
            return;
        }

        if (isReplaceSlot)
        {
            rulesManager.ReplaceBallInLoadout(_pendingReplaceSlotIndex, _pendingItem);
        }
        else if (isAddSlot)
        {
            rulesManager.AddBallToLoadout(_pendingItem);
        }

        SetPrompt($"Purchased {_pendingItem.GetSafeDisplayName()}.");
        FMODUnity.RuntimeManager.PlayOneShot("event:/button_click");
        _pendingItem = null;
        _pendingReplaceSlotIndex = -1;
        SetReplacePanelOpen(false);
        ClearReplaceConfirmationVisuals();
        RebuildReplaceSlots();
        RebuildOffers();
        RefreshUI();
    }

    public void CancelReplaceConfirmation()
    {
        if (_pendingItem == null)
        {
            SetReplacePanelOpen(false);
            ClearReplaceConfirmationVisuals();
            return;
        }

        _pendingReplaceSlotIndex = -1;
        SetReplacePanelOpen(false);
        ClearReplaceConfirmationVisuals();
        SetPrompt($"Select a ball to replace with {_pendingItem.GetSafeDisplayName()} (${_pendingItem.Price}).");
        FMODUnity.RuntimeManager.PlayOneShot("event:/button_click");
        RefreshUI();
    }

    private void RefreshReplaceConfirmationText()
    {
        if (replaceConfirmText == null || rulesManager == null)
        {
            return;
        }

        if (_pendingItem == null || _pendingReplaceSlotIndex < 0)
        {
            replaceConfirmText.text = string.Empty;
            SetReplaceConfirmationIcons(currentBallIcon: null, incomingBallIcon: null);
            return;
        }

        List<BallDefinition> loadout = rulesManager.GetBallLoadoutSnapshot();
        int count = loadout.Count;
        int cap = Mathf.Max(1, rulesManager.MaxBalls);

        string newName = _pendingItem.GetSafeDisplayName();
        Sprite incomingIcon = _pendingItem.Icon;

        if (_pendingReplaceSlotIndex < count)
        {
            Sprite currentIcon = loadout[_pendingReplaceSlotIndex] != null
                ? loadout[_pendingReplaceSlotIndex].Icon
                : null;
            string oldName = loadout[_pendingReplaceSlotIndex] != null
                ? loadout[_pendingReplaceSlotIndex].GetSafeDisplayName()
                : "(None)";
            replaceConfirmText.text = $"Replace {oldName} with {newName} for ${_pendingItem.Price}?";
            SetReplaceConfirmationIcons(currentBallIcon: currentIcon, incomingBallIcon: incomingIcon);
        }
        else if (_pendingReplaceSlotIndex == count && count < cap)
        {
            replaceConfirmText.text = $"Add {newName} to Slot {_pendingReplaceSlotIndex + 1} for ${_pendingItem.Price}?";
            SetReplaceConfirmationIcons(currentBallIcon: null, incomingBallIcon: incomingIcon);
        }
        else
        {
            replaceConfirmText.text = string.Empty;
            SetReplaceConfirmationIcons(currentBallIcon: null, incomingBallIcon: null);
        }
    }

    private void RebuildReplaceSlots()
    {
        if (replaceSlotsContainer == null || replaceSlotEntryPrefab == null || rulesManager == null)
        {
            return;
        }

        ClearReplaceSlots();

        List<BallDefinition> loadout = rulesManager.GetBallLoadoutSnapshot();
        for (int i = 0; i < loadout.Count; i++)
        {
            BallDefinition def = loadout[i];
            string ballName = def != null ? def.GetSafeDisplayName() : "(None)";
            Sprite icon = def != null ? def.Icon : null;

            BallReplaceSlotEntryUI entry = Instantiate(replaceSlotEntryPrefab, replaceSlotsContainer);
            entry.Init(this, i, $"Slot {i + 1}: {ballName}", icon);
        }

        int cap = Mathf.Max(1, rulesManager.MaxBalls);
        if (loadout.Count < cap)
        {
            int slotIndex = loadout.Count;
            BallReplaceSlotEntryUI entry = Instantiate(replaceSlotEntryPrefab, replaceSlotsContainer);
            entry.Init(this, slotIndex, $"Slot {slotIndex + 1}: Empty", icon: null);
        }
    }

    private void ClearReplaceSlots()
    {
        if (replaceSlotsContainer == null)
        {
            return;
        }

        for (int i = replaceSlotsContainer.childCount - 1; i >= 0; i--)
        {
            Destroy(replaceSlotsContainer.GetChild(i).gameObject);
        }
    }

    private void RebuildOffers()
    {
        if (offersContainer == null || offerEntryPrefab == null)
        {
            return;
        }

        ClearOffers();
        RollNewOffers();
        ClearSelectedSelection();

        for (int i = 0; i < _currentOffers.Count; i++)
        {
            BallDefinition item = _currentOffers[i];
            if (item == null || !item.IsValid()) continue;

            ShopBallOfferEntryUI entry = Instantiate(offerEntryPrefab, offersContainer);
            entry.Init(this, i, item.GetSafeDisplayName(), item.Price, item.Icon);
            _offerEntries.Add(entry);
        }
    }

    private void ClearOffers()
    {
        _currentOffers.Clear();
        _offerEntries.Clear();

        if (offersContainer == null) return;
        for (int i = offersContainer.childCount - 1; i >= 0; i--)
        {
            Destroy(offersContainer.GetChild(i).gameObject);
        }
    }

    private void RollNewOffers()
    {
        _currentOffers.Clear();

        IList<BallDefinition> catalog = GetCatalog();
        if (catalog == null || catalog.Count == 0)
        {
            return;
        }

        int target = Mathf.Max(0, offersPerShop);
        if (target == 0) return;

        // Build list of valid indices (non-null definition + prefab).
        List<int> valid = new List<int>(catalog.Count);
        for (int i = 0; i < catalog.Count; i++)
        {
            var it = catalog[i];
            if (it != null && it.IsValid())
            {
                valid.Add(i);
            }
        }

        if (valid.Count == 0)
        {
            return;
        }

        // Partial shuffle to pick up to target unique items.
        int picks = Mathf.Min(target, valid.Count);
        for (int i = 0; i < picks; i++)
        {
            int j = UnityEngine.Random.Range(i, valid.Count);
            (valid[i], valid[j]) = (valid[j], valid[i]);
            _currentOffers.Add(catalog[valid[i]]);
        }
    }

    private IList<BallDefinition> GetCatalog()
    {
        if (allBallDefinitions != null && allBallDefinitions.Count != 0)
        {
            return allBallDefinitions;
        }

        BuildLegacyRuntimeDefinitionsIfNeeded();
        return _legacyRuntimeDefinitions;
    }

    private void BuildLegacyRuntimeDefinitionsIfNeeded()
    {
        if (_legacyRuntimeDefinitionsBuilt)
        {
            return;
        }

        _legacyRuntimeDefinitionsBuilt = true;
        _legacyRuntimeDefinitions.Clear();

        if (allBallItems == null || allBallItems.Count == 0)
        {
            return;
        }

        for (int i = 0; i < allBallItems.Count; i++)
        {
            BallShopItem item = allBallItems[i];
            if (item == null || item.ballPrefab == null)
            {
                continue;
            }

            Sprite icon = item.iconOverride != null
                ? item.iconOverride
                : BallDefinitionUtilities.TryGetPrefabSpriteIcon(item.ballPrefab);

            var def = BallDefinition.CreateRuntime(
                runtimeId: item.ballPrefab.name,
                runtimeDisplayName: item.displayName,
                runtimeDescription: item.description,
                runtimeRarity: ConvertLegacyRarity(item.rarity),
                runtimeIcon: icon,
                runtimePrefab: item.ballPrefab,
                runtimePrice: item.cost);

            _legacyRuntimeDefinitions.Add(def);
        }
    }

    private static global::BallRarity ConvertLegacyRarity(BallRarity legacy)
    {
        switch (legacy)
        {
            case BallRarity.Uncommon:
                return global::BallRarity.Uncommon;
            case BallRarity.Rare:
                return global::BallRarity.Rare;
            case BallRarity.Epic:
                return global::BallRarity.Epic;
            case BallRarity.Legendary:
                return global::BallRarity.Legendary;
            case BallRarity.Common:
            default:
                return global::BallRarity.Common;
        }
    }

    private void SetReplacePanelOpen(bool open)
    {
        if (replacePanelRoot != null)
        {
            replacePanelRoot.SetActive(open);
        }
    }

    private void ClearReplaceConfirmationVisuals()
    {
        if (replaceConfirmText != null)
        {
            replaceConfirmText.text = string.Empty;
        }

        SetReplaceConfirmationIcons(currentBallIcon: null, incomingBallIcon: null);
    }

    private void SetReplaceConfirmationIcons(Sprite currentBallIcon, Sprite incomingBallIcon)
    {
        ResolveReplacePanelIconImagesIfNeeded();

        if (replaceCurrentBallIconImage != null)
        {
            replaceCurrentBallIconImage.sprite = currentBallIcon;
            replaceCurrentBallIconImage.enabled = currentBallIcon != null;
        }

        if (replaceIncomingBallIconImage != null)
        {
            replaceIncomingBallIconImage.sprite = incomingBallIcon;
            replaceIncomingBallIconImage.enabled = incomingBallIcon != null;
        }
    }

    private void ResolveReplacePanelIconImagesIfNeeded()
    {
        if (replacePanelRoot == null)
        {
            return;
        }

        if (replaceCurrentBallIconImage != null && replaceIncomingBallIconImage != null)
        {
            return;
        }

        Image[] images = replacePanelRoot.GetComponentsInChildren<Image>(includeInactive: true);
        for (int i = 0; i < images.Length; i++)
        {
            Image img = images[i];
            if (img == null)
            {
                continue;
            }

            if (replaceCurrentBallIconImage == null && img.gameObject.name == "Current ball Icon")
            {
                replaceCurrentBallIconImage = img;
                continue;
            }

            if (replaceIncomingBallIconImage == null && img.gameObject.name == "Swap ball icon")
            {
                replaceIncomingBallIconImage = img;
            }

            if (replaceCurrentBallIconImage != null && replaceIncomingBallIconImage != null)
            {
                return;
            }
        }
    }

    private void SetPrompt(string msg)
    {
        if (promptText != null)
        {
            promptText.text = msg ?? string.Empty;
        }
    }

    private void DisableBuyButtonIfPresent()
    {
        if (selectedBuyButton == null)
        {
            return;
        }

        selectedBuyButton.onClick.RemoveListener(BuySelectedOffer);
        selectedBuyButton.interactable = false;
        selectedBuyButton.gameObject.SetActive(false);
    }

    private void ClearSelectedSelection()
    {
        _selectedOfferIndex = -1;
        _selectedHandSlotIndex = -1;
        RefreshSelectedPanel();
        RefreshOfferEntrySelectionVisuals();
    }

    private void RefreshOfferEntrySelectionVisuals()
    {
        for (int i = 0; i < _offerEntries.Count; i++)
        {
            ShopBallOfferEntryUI entry = _offerEntries[i];
            if (entry == null)
            {
                continue;
            }

            entry.SetSelected(i == _selectedOfferIndex);
        }
    }

    private void RefreshSelectedPanel()
    {
        BallDefinition item = null;
        bool showOwnedBall = false;

        if (_selectedOfferIndex >= 0 && _selectedOfferIndex < _currentOffers.Count)
        {
            item = _currentOffers[_selectedOfferIndex];
        }
        else if (rulesManager != null && _selectedHandSlotIndex >= 0)
        {
            List<BallDefinition> loadout = rulesManager.GetBallLoadoutSnapshot();
            if (_selectedHandSlotIndex >= 0 && _selectedHandSlotIndex < loadout.Count)
            {
                item = loadout[_selectedHandSlotIndex];
                showOwnedBall = true;
            }
        }

        bool hasSelection = item != null;

        if (selectedEmptyStateRoot != null)
        {
            selectedEmptyStateRoot.SetActive(!hasSelection);
        }

        if (selectedDetailsRoot != null)
        {
            selectedDetailsRoot.SetActive(hasSelection);
        }

        if (!hasSelection)
        {
            if (selectedIconImage != null)
            {
                selectedIconImage.enabled = false;
                selectedIconImage.sprite = null;
            }

            if (selectedNameText != null) selectedNameText.text = string.Empty;
            if (selectedPriceText != null) selectedPriceText.text = string.Empty;
            if (selectedDescriptionText != null) selectedDescriptionText.text = string.Empty;
            if (selectedRarityText != null) selectedRarityText.text = string.Empty;
            return;
        }

        Sprite icon = item.Icon;
        if (selectedIconImage != null)
        {
            if (icon != null)
            {
                selectedIconImage.enabled = true;
                selectedIconImage.sprite = icon;
            }
            else
            {
                selectedIconImage.enabled = false;
                selectedIconImage.sprite = null;
            }
        }

        if (selectedNameText != null) selectedNameText.text = item.GetSafeDisplayName();
        if (selectedPriceText != null)
        {
            selectedPriceText.text = showOwnedBall ? "Owned" : $"${item.Price}";
        }
        if (selectedDescriptionText != null) selectedDescriptionText.text = item.Description ?? string.Empty;
        if (selectedRarityText != null) selectedRarityText.text = item.Rarity.ToString();
    }
}

